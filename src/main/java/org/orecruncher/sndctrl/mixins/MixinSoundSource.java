/*
 * Dynamic Surroundings: Sound Control
 * Copyright (C) 2020 OreCruncher
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package org.orecruncher.sndctrl.mixins;

import net.minecraft.client.audio.AudioStreamBuffer;
import net.minecraft.client.audio.IAudioStream;
import net.minecraft.client.audio.SoundSource;
import org.lwjgl.openal.AL10;
import org.orecruncher.lib.IDataAccessor;
import org.orecruncher.sndctrl.audio.handlers.SoundFXProcessor;
import org.orecruncher.sndctrl.audio.handlers.SourceContext;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import javax.annotation.Nullable;

@Mixin(SoundSource.class)
public class MixinSoundSource implements IDataAccessor<SourceContext> {

    private SourceContext sndctrl_data = null;

    @Shadow
    private int field_216443_d;

    @Nullable
    @Override
    public SourceContext getData() {
        return this.sndctrl_data;
    }

    @Override
    public void setData(@Nullable SourceContext data) {
        this.sndctrl_data = data;
    }

    /**
     * Called when the sound is ticked by the sound engine. This will set the sound effect properties for the sound
     * at the time of play.
     * @param ci Ignored
     */
    @Inject(method = "play()V", at = @At("HEAD"))
    public void onPlay(CallbackInfo ci)
    {
        SoundFXProcessor.tick((SoundSource)((Object)this));
    }

    /**
     * Called when the sound is ticked by the sound engine. This will set the sound effect properties for the sound
     * at the time of tick.
     * @param ci Ignored
     */
    @Inject(method = "tick()V", at = @At("HEAD"))
    public void onTick(CallbackInfo ci)
    {
        SoundFXProcessor.tick((SoundSource)((Object)this));
    }

    /**
     * Called when a sounds stops playing.  Any context information sndctrl has generated will be cleaned up.
     * @param ci Ignored
     */
    @Inject(method = "stop()V", at = @At("HEAD"))
    public void onStop(CallbackInfo ci)
    {
        SoundFXProcessor.stopSoundPlay((SoundSource)((Object)this));
    }

    /**
     * Adjusts the calculated IO buffer size for the streaming sound.  This is necessary because the sound engine does
     * not handle repeating streaming sounds correctly.  This will force the engine to load the entire sound clip so it
     * can properly loop.
     * @param p_216433_1_ Ignored
     * @param ci Ignored
     */
    @Inject(method = "func_216433_a(Lnet/minecraft/client/audio/IAudioStream;)V", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/audio/SoundSource;func_216417_a(Ljavax/sound/sampled/AudioFormat;I)I", shift = At.Shift.AFTER))
    public void adjustBufferSize(IAudioStream p_216433_1_, CallbackInfo ci)
    {
        this.field_216443_d *= 16;
    }

    /**
     * Called after the audio stream buffer has been generated by the sound engine.  If the sound has non-linear
     * attenuation and is not mono, it will be convered to mono format.  Non-mono sounds will be played in the sound engine
     * as if they are non-linear because it cannnot convert non-mono sounds for 3D environmental play.
     * @param p_216429_1_ Buffer to convert to mono if needed.
     * @param ci Call will always be cancelled.
     */
    @Inject(method = "func_216429_a(Lnet/minecraft/client/audio/AudioStreamBuffer;)V", at = @At("HEAD"), cancellable = true)
    public void onPlayBuffer(AudioStreamBuffer p_216429_1_, CallbackInfo ci)
    {
        final SoundSource src = (SoundSource)((Object)this);

        p_216429_1_ = SoundFXProcessor.playBuffer(src, p_216429_1_);

        p_216429_1_.getBuffer().ifPresent((p_216431_1_) -> {
            AL10.alSourcei(src.id, 4105, p_216431_1_);
        });

        ci.cancel();
    }
}
